open Mathext

const pid_roll_rate_kp: float = 250.0
const pid_roll_rate_ki: float = 500.0
const pid_roll_rate_kd: float = 2.5
const pid_roll_rate_integration_limit: float = 33.3
const pid_roll_rate_integration_lim: bool = true

const pid_pitch_rate_kp: float = 250.0
const pid_pitch_rate_ki: float = 500.0
const pid_pitch_rate_kd: float = 2.5
const pid_pitch_rate_integration_limit: float = 33.3
const pid_pitch_rate_integration_lim: bool = true

const pid_yaw_rate_kp: float = 120.0
const pid_yaw_rate_ki: float = 16.7
const pid_yaw_rate_kd: float = 0.0
const pid_yaw_rate_integration_limit: float = 166.7
const pid_yaw_rate_integration_lim: bool = true

const pid_roll_kp: float = 6.0
const pid_roll_ki: float = 3.0
const pid_roll_kd: float = 0.0
const pid_roll_integration_limit: float = 20.0
const pid_roll_integration_lim: bool = true

const pid_pitch_kp: float = 6.0
const pid_pitch_ki: float = 3.0
const pid_pitch_kd: float = 0.0
const pid_pitch_integration_limit: float = 20.0
const pid_pitch_integration_lim: bool = true

const pid_yaw_kp: float = 6.0
const pid_yaw_ki: float = 1.0
const pid_yaw_kd: float = 0.35
const pid_yaw_integration_limit: float = 360.0
const pid_yaw_integration_lim: bool = true

const attitude_lpf_cutoff_freq: float = 15.0
const attitude_lpf_enable: bool = false
const attitude_lpf_rate_cutoff_freq: float = 30.0
const attitude_lpf_rate_enable: bool = false

const rate_1000_hz: float = 1000.0
const rate_500_hz: float = 500.0
const rate_250_hz: float = 250.0
const rate_100_hz: float = 100.0
const rate_50_hz: float = 50.0
const rate_25_hz: float = 25.0

const rate_main_loop: float = rate_1000_hz
const attitude_rate: float = rate_500_hz
const position_rate: float = rate_100_hz
const rate_hl_commander: float = rate_100_hz

const attitude_update_rate: float = rate_500_hz
const attitude_update_dt: float = 1.0 /. attitude_update_rate

const pos_update_rate: float = rate_100_hz
const pos_update_dt: float = 1.0 /. pos_update_rate

const pos_filt_enable: bool = true
const vel_filt_enable: bool = true
const pos_filt_cutoff: float = 20.0
const vel_filt_cutoff: float = 20.0
const posz_filt_enable: bool = true
const velz_filt_enable: bool = true
const posz_filt_cutoff: float = 20.0
const velz_filt_cutoff: float = 20.0

(* Libel__pid_params_25_0000001_0000000_0000000_010000100_00000020_000000truetruetrue5000_00000022_000000__step *)
const pid_vx_kp: float = 25.0
const pid_vx_ki: float = 1.0
const pid_vx_kd: float = 0.0
const pid_vx_dt: float = pos_update_dt

(* Libel__pid_params_25_0000001_0000000_0000000_010000100_00000020_000000truetruetrue5000_00000022_000000__step *)
const pid_vy_kp: float = 25.0
const pid_vy_ki: float = 1.0
const pid_vy_kd: float = 0.0
const pid_vy_dt: float = pos_update_dt

(* Libel__pid_params_25_00000015_0000000_0000000_010000100_00000020_000000truetruetrue5000_00000032_767500__step *)
const pid_vz_kp: float = 25.0
const pid_vz_ki: float = 15.0
const pid_vz_kd: float = 0.0
const pid_vz_dt: float = pos_update_dt

(* Libel__pid_params_2_0000000_0000000_0000000_010000100_00000020_000000truetruefalse5000_0000000_000000__step *)
const pid_x_kp: float = 2.0
const pid_x_ki: float = 0.0
const pid_x_kd: float = 0.0
const pid_x_dt: float = pos_update_dt

(* Libel__pid_params_2_0000000_0000000_0000000_010000100_00000020_000000truetruefalse5000_0000000_000000__step *)
const pid_y_kp: float = 2.0
const pid_y_ki: float = 0.0
const pid_y_kd: float = 0.0
const pid_y_dt: float = pos_update_dt

(* Libel__pid_params_2_0000000_5000000_0000000_010000100_00000020_000000truetruefalse5000_0000000_000000__step *)
const pid_z_kp: float = 2.0
const pid_z_ki: float = 0.5
const pid_z_kd: float = 0.0
const pid_z_dt: float = pos_update_dt


(* Libel__constrain_params__5000_0000005000_000000__step *)
const default_pid_integration_limit: float = 5000.0
const default_pid_integration_lim: bool = true
(* Libel__constrain_params__0_0000000_000000__step *)
const default_pid_output_limit: float = 0.0
const default_pid_output_lim: bool = false


const thrust_base: float = 36000.0
(* Libel__constrain_params_20000_00000065535_000000__step *)
const thrust_min: float = 20000.0
(* Libel__constrain_params__20_00000020_000000__step *)
const rollLimit : float = 20.0
const pitchLimit : float = 20.0
const rpLimitOverhead : float = 1.10

const xVelMax : float = 1.0
const yVelMax : float = 1.0
const zVelMax : float = 1.0
const velMaxOverhead : float = 1.10

const thrustScale : float = 1000.0

const pi: float = 3.14159265358979323846

const max_uint16 : int = 0xffff
const max_int16 : int = 0x7fff
const max_uint16_f : float = 65535.0

fun lpf2pSetCutoffFreq(sample_freq, cutoff_freq: float) returns (b0, b1, b2, a1, a2: float)
var fr, ohm, c: float;
let
    fr = sample_freq /. cutoff_freq;
    ohm = tan( pi /. fr );
    c = 1.0 +. 2.0 *. cos( pi /. 4.0 ) *. ohm +. ohm *. ohm;
    b0 = ohm *. ohm /. c;
    b1 = 2.0 *. b0;
    b2 = b0;
    a1 = 2.0 *. ( ohm *. ohm -. 1.0) /. c;
    a2 = ( 1.0 -. 2.0 *. cos( pi /. 4.0 ) *. ohm +. ohm *. ohm ) /. c;
tel



node constrain<<min, max : float>>(input : float) returns (output : float)
let
    output = 
        if input <. min then 
            min 
        else if input >. max then
            max
        else
            input;
tel

node opt_constrain<<limit : float>>(input : float) returns (output : float)
var lim : bool;
let
    lim = round(limit) <> 0;
    output = 
        if lim then constrain<< -. limit, limit>>(input)
        else input;
tel

node lpf2p<<samplingRate, cutoffFreq : float; enableDFilter : bool>>(sample : float) returns (output : float)
var out_filter, delay_0, delay_1, delay_2 : float;
    b0, b1, b2, a1, a2: float;
let
    (b0, b1, b2, a1, a2) = lpf2pSetCutoffFreq(samplingRate, cutoffFreq);

    delay_0 = sample -. delay_1 *. a1 -. delay_2 *. a2;
    out_filter = delay_0 *. b0 +. delay_1 *. b1 +. delay_2 *. b2;
    delay_1 = 0.0 fby delay_0;
    delay_2 = 0.0 fby delay_1;

    output = if enableDFilter then out_filter else sample;
tel

node pid_err<<kp, ki, kd, dt, samplingRate, cutoffFreq : float;
            enableDFilter : bool;
            iLimit, oLimit: float>>(err: float) returns (output : float)
var prev_err, integ : float; (* PID memory *)
    deriv : float;
let
    prev_err = 0.0 fby err;
    integ = opt_constrain<<iLimit>>(0.0 fby integ +. err *. dt);
    deriv = lpf2p<<samplingRate, cutoffFreq, enableDFilter>>((err -. prev_err) /. dt);

    output = opt_constrain<<oLimit>>(kp *. err +. ki *. integ +. kd *. deriv);
tel

node pid<<kp, ki, kd, dt, samplingRate, cutoffFreq : float;
            enableDFilter : bool;
            iLimit, oLimit: float>>(desired, measured : float) returns (output : float)
let
    output = pid_err<<kp, ki, kd, dt, samplingRate, cutoffFreq,
                      enableDFilter,
                      iLimit, oLimit>>(desired -. measured);
tel

(** Position Controller *)

type vec3 = {
     x : float;
     y : float;
     z : float
}

type attitude = {
     roll : float;
     pitch : float;
     yaw : float
}

type quaternion = {
     qx : float;
     qy : float;
     qz : float;
     qw : float
}

type stab_mode = Disable | Abs | Velocity

type mode = {
     mx : stab_mode;
     my : stab_mode;
     mz : stab_mode;
     mroll : stab_mode;
     mpitch : stab_mode;
     myaw : stab_mode;
     mquat : stab_mode
}

type baro = {
     pressure : float;
     temperature : float;
     asl : float
}

type sensor_data = {
     acc : vec3;
     gyro : vec3;
     mag : vec3;
     baro : baro
}

type setpoint = {
     attitude : attitude;
     attitude_rate : attitude;
     attitude_quat : quaternion;
     thrust : float;
     position : vec3;
     velocity : vec3;
     acceleration : vec3;
     velocity_body : bool;
     mode : mode
}

type state_t = {
     st_attitude : attitude;
     st_attitude_quat : quaternion;
     st_position : vec3;
     st_velocity : vec3;
     st_acc : vec3
}

node everyn<<n : int>>() returns (v : bool);
var x : int;
let
  x = 0 fby ((x + 1) % n);
  v = (x = 0);
tel

node cap_angle(x : float)
returns (y : float)
let
  y = if x >. 180.0 then fmod(x, 360.0) -. 360.0
      else if x <. -.180.0 then fmod(x, 360.0) +. 360.0
      else x
tel

node velocity_controller(velocity : vec3; st : state_t) returns (thrust, pitch, roll : float)
var cosyaw, sinyaw, state_body_vx, state_body_vy, thrustRaw : float;
let
    cosyaw = cos(st.st_attitude.yaw *. pi /. 180.0);
    sinyaw = sin(st.st_attitude.yaw *. pi /. 180.0);

    state_body_vx = st.st_velocity.x *. cosyaw +. st.st_velocity.y *. sinyaw;
    state_body_vy = -. st.st_velocity.x *. sinyaw +. st.st_velocity.y *. cosyaw;

    pitch =
    constrain<<  -. pitchLimit, pitchLimit>>(
        -.pid<<pid_vx_kp, pid_vx_ki, pid_vx_kd, pos_update_dt,
             position_rate, vel_filt_cutoff, vel_filt_enable,
             default_pid_integration_limit, pitchLimit *. rpLimitOverhead>>
             (velocity.x, state_body_vx)
    );

    roll =
    constrain<< -. rollLimit, rollLimit>>(
        -.pid<<pid_vy_kp, pid_vy_ki, pid_vy_kd, pos_update_dt,
             position_rate, vel_filt_cutoff, vel_filt_enable,
             default_pid_integration_limit, rollLimit *. rpLimitOverhead>>
             (velocity.y, state_body_vy)
    );

    thrustRaw =
    pid<<pid_vz_kp, pid_vz_ki, pid_vz_kd, pos_update_dt,
                     position_rate, velz_filt_cutoff, velz_filt_enable,
                     default_pid_integration_limit, max_uint16_f /. 2.0 /. thrustScale>>
                (velocity.z, st.st_velocity.z);

    thrust =
    constrain<<thrust_min, max_uint16_f>>(thrustRaw *. thrustScale +. thrust_base);
tel

node position_controller(setpoint: setpoint; st : state_t)
returns (thrust, pitch, roll: float)
var cosyaw, sinyaw, setp_body_x, setp_body_y, state_body_x, state_body_y: float;
    velocity : vec3;
let
    cosyaw = cos(st.st_attitude.yaw *. pi /. 180.0);
    sinyaw = sin(st.st_attitude.yaw *. pi /. 180.0);

    setp_body_x = setpoint.position.x *. cosyaw +. setpoint.position.y *. sinyaw;
    setp_body_y = -. setpoint.position.x *. sinyaw +. setpoint.position.y *. cosyaw;

    state_body_x = st.st_position.x *. cosyaw +. st.st_position.y *. sinyaw;
    state_body_y = -. st.st_position.x *. sinyaw +. st.st_position.y *. cosyaw;

    velocity = {
        x =
            if setpoint.mode.mx = Abs then
                pid<<pid_x_kp, pid_x_ki, pid_x_kd, pos_update_dt,
                    position_rate, pos_filt_cutoff, pos_filt_enable,
                    default_pid_integration_limit, xVelMax *. velMaxOverhead>>
                (setp_body_x, state_body_x)
            else if not setpoint.velocity_body then
                setpoint.velocity.x *. cosyaw +. setpoint.velocity.y *. sinyaw
            else
                setpoint.velocity.x
            ;

        y =
            if setpoint.mode.my = Abs then
                pid<<pid_y_kp, pid_y_ki, pid_y_kd, pos_update_dt,
                    position_rate, pos_filt_cutoff, pos_filt_enable,
                    default_pid_integration_limit, yVelMax *. velMaxOverhead>>
                (setp_body_y, state_body_y)
            else if not setpoint.velocity_body then
                setpoint.velocity.y *. cosyaw -. setpoint.velocity.x *. sinyaw
            else
                setpoint.velocity.y
            ;

        z =
            if setpoint.mode.mz = Abs then
                pid<<pid_z_kp, pid_z_ki, pid_z_kd, pos_update_dt,
                    position_rate, posz_filt_cutoff, posz_filt_enable,
                    default_pid_integration_limit, zVelMax *. velMaxOverhead>>
                (setpoint.position.z, st.st_position.z)
            else
                setpoint.velocity.z
    };

    (thrust, pitch, roll) = velocity_controller(velocity, st);
tel

node controller_pid1(setpoint : setpoint; st : state_t)
returns (last thrust : float = 0.0;
         last att_desired : attitude = { pitch = 0.0; roll = 0.0; yaw = 0.0 });
var ck_attitude, ck_position : bool; thrustd, pitch, roll, yaw : float;
let
    ck_attitude = everyn<<2>>();
    ck_position = everyn<<10>>();

    switch ck_attitude
    | true do yaw =
        if setpoint.mode.myaw = Velocity
        then cap_angle((last att_desired).yaw +. setpoint.attitude_rate.yaw *. attitude_update_dt)
        else cap_angle(setpoint.attitude.yaw)
    | false do yaw = (last att_desired).yaw;
    end;

    switch ck_position
    | true do
        (thrustd, pitch, roll) = position_controller(setpoint, st);
    | false do
        thrustd = last thrust;
        pitch = (last att_desired).pitch;
        roll = (last att_desired).roll;
    end;

    switch ck_attitude
    | true do
        thrust = if setpoint.mode.mz = Disable then setpoint.thrust else thrustd;
        switch (setpoint.mode.mx = Disable or setpoint.mode.my = Disable)
        | true do att_desired = { setpoint.attitude with .yaw = yaw }
        | false do att_desired = { pitch = pitch; roll = roll; yaw = yaw }
        end
    | false do
    end;
tel

(** Attitude Controller *)

node attitudeControllerCorrectAttitudePID
    (eulerRollActual, eulerPitchActual, eulerYawActual,
     eulerRollDesired, eulerPitchDesired, eulerYawDesired : float;
     setpoint : setpoint)
    returns (rollRateDesired, pitchRateDesired, yawRateDesired : float);
var yaw_err, real_yaw_err, rollRateDesired_pid, pitchRateDesired_pid : float;
    resetRoll, resetPitch : bool;
let
    resetRoll = setpoint.mode.mroll = Velocity;
    resetPitch = setpoint.mode.mpitch = Velocity;

    yaw_err = eulerYawDesired -. eulerYawActual;
    real_yaw_err = 
        if yaw_err >. 180.0 then
            yaw_err -. 360.0
        else if yaw_err <. -. 180.0 then
            yaw_err +. 360.0
        else
            yaw_err;

    reset
        rollRateDesired_pid = 
            pid<<pid_roll_kp, pid_roll_ki, pid_roll_kd,
                 attitude_update_dt, attitude_rate, attitude_lpf_cutoff_freq,
                 attitude_lpf_enable,
                 pid_roll_integration_limit, 0.0>>(eulerRollDesired, eulerRollActual)
    every resetRoll;

    reset
        pitchRateDesired_pid =
            pid<<pid_pitch_kp, pid_pitch_ki, pid_pitch_kd,
                 attitude_update_dt, attitude_rate, attitude_lpf_cutoff_freq,
                 attitude_lpf_enable,
                 pid_pitch_integration_limit, 0.0>>(eulerPitchDesired, eulerPitchActual)
    every resetPitch;

    rollRateDesired = 
        if resetRoll then
            setpoint.attitude_rate.roll
        else
            rollRateDesired_pid;

    pitchRateDesired =
        if resetPitch then
            setpoint.attitude_rate.pitch
        else
            pitchRateDesired_pid;


    yawRateDesired =
        pid_err<<pid_yaw_kp, pid_yaw_ki, pid_yaw_kd,
                 attitude_update_dt, attitude_rate, attitude_lpf_cutoff_freq,
                 attitude_lpf_enable,
                 pid_yaw_integration_limit, 0.0>>
                 (real_yaw_err);
tel

node saturate_int16(xf : float) returns (y : int)
var x : int;
let
    x = round(floor(xf));
    y = if x > max_int16 then max_int16
        else if x < -max_int16 then -max_int16 else x
tel

node attitudeControllerCorrectRatePID
    (rollRateActual, pitchRateActual, yawRateActual,
     rollRateDesired, pitchRateDesired, yawRateDesired : float)
    returns (rollOutput, pitchOutput, yawOutput : int);
var rollOutput_float, pitchOutput_float, yawOutput_float : float;
let
    rollOutput_float =
        pid<<pid_roll_rate_kp, pid_roll_rate_ki, pid_roll_rate_kd,
             attitude_update_dt, attitude_rate, attitude_lpf_rate_cutoff_freq,
             attitude_lpf_rate_enable,
             pid_roll_rate_integration_limit, 0.0>>(rollRateDesired, rollRateActual);

    pitchOutput_float =
        pid<<pid_pitch_rate_kp, pid_pitch_rate_ki, pid_pitch_rate_kd,
             attitude_update_dt, attitude_rate, attitude_lpf_rate_cutoff_freq,
             attitude_lpf_rate_enable,
             pid_pitch_rate_integration_limit, 0.0>>(pitchRateDesired, pitchRateActual);

    yawOutput_float =
        pid<<pid_yaw_rate_kp, pid_yaw_rate_ki, pid_yaw_rate_kd,
             attitude_update_dt, attitude_rate, attitude_lpf_rate_cutoff_freq,
             attitude_lpf_rate_enable,
             pid_yaw_rate_integration_limit, 0.0>>(yawRateDesired, yawRateActual);

    rollOutput  = saturate_int16(rollOutput_float);
    pitchOutput = saturate_int16(pitchOutput_float);
    yawOutput   = - saturate_int16(yawOutput_float);
tel

node attitudeController(attitudeDesired : attitude;
                        st : state_t;
                        sensors : sensor_data;
                        setpoint : setpoint)
    returns (roll, pitch, yaw : int);
var rollRateDesired, pitchRateDesired, yawRateDesired : float;
let
    (rollRateDesired, pitchRateDesired, yawRateDesired) = 
        attitudeControllerCorrectAttitudePID(
            st.st_attitude.roll, st.st_attitude.pitch, st.st_attitude.yaw,
            attitudeDesired.roll, attitudeDesired.pitch, attitudeDesired.yaw,
            setpoint
        );

    (roll,pitch,yaw) = attitudeControllerCorrectRatePID(
            sensors.gyro.x, -. sensors.gyro.y, sensors.gyro.z,
            rollRateDesired, pitchRateDesired, yawRateDesired
        );
tel

(** Power distribution *)

fun limitUint16(i : int) returns (o : int)
let
    o = if i > max_uint16 then max_uint16
        else if i < 0 then 0 else i;
tel

const idle_thrust : int = 0

fun min_idle(i : int) returns (o : int)
let
    o = if i < idle_thrust then idle_thrust else i;
tel

fun power_distribution(thrust : float; roll, pitch, yaw : int)
returns (m1, m2, m3, m4 : int)
var r, p, t : int;
let
    r = roll / 2;
    p = pitch / 2;
    t = round(thrust);
    m1 = min_idle(limitUint16(t - r + p + yaw));
    m2 = min_idle(limitUint16(t - r - p - yaw));
    m3 = min_idle(limitUint16(t + r - p + yaw));
    m4 = min_idle(limitUint16(t + r + p - yaw));
tel
