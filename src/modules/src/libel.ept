open Mathext

const pid_roll_rate_kp: float = 250.0
const pid_roll_rate_ki: float = 500.0
const pid_roll_rate_kd: float = 2.5
const pid_roll_rate_integration_limit: float = 33.3
const pid_roll_rate_integration_lim: bool = true

const pid_pitch_rate_kp: float = 250.0
const pid_pitch_rate_ki: float = 500.0
const pid_pitch_rate_kd: float = 2.5
const pid_pitch_rate_integration_limit: float = 33.3
const pid_pitch_rate_integration_lim: bool = true

const pid_yaw_rate_kp: float = 120.0
const pid_yaw_rate_ki: float = 16.7
const pid_yaw_rate_kd: float = 0.0
const pid_yaw_rate_integration_limit: float = 166.7
const pid_yaw_rate_integration_lim: bool = true

const pid_roll_kp: float = 6.0
const pid_roll_ki: float = 3.0
const pid_roll_kd: float = 0.0
const pid_roll_integration_limit: float = 20.0
const pid_roll_integration_lim: bool = true

const pid_pitch_kp: float = 6.0
const pid_pitch_ki: float = 3.0
const pid_pitch_kd: float = 0.0
const pid_pitch_integration_limit: float = 20.0
const pid_pitch_integration_lim: bool = true

const pid_yaw_kp: float = 6.0
const pid_yaw_ki: float = 1.0
const pid_yaw_kd: float = 0.35
const pid_yaw_integration_limit: float = 360.0
const pid_yaw_integration_lim: bool = true

const attitude_lpf_cutoff_freq: float = 15.0
const attitude_lpf_enable: bool = false
const attitude_lpf_rate_cutoff_freq: float = 30.0
const attitude_lpf_rate_enable: bool = false

const rate_1000_hz: float = 1000.0
const rate_500_hz: float = 500.0
const rate_250_hz: float = 250.0
const rate_100_hz: float = 100.0
const rate_50_hz: float = 50.0
const rate_25_hz: float = 25.0

const rate_main_loop: float = rate_1000_hz
const attitude_rate: float = rate_500_hz
const position_rate: float = rate_100_hz
const rate_hl_commander: float = rate_100_hz

const attitude_update_rate: float = rate_500_hz
const attitude_update_dt: float = 1.0 /. attitude_update_rate

const pos_update_rate: float = rate_100_hz
const pos_update_dt: float = 1.0 /. pos_update_rate

const pos_filt_enable: bool = true
const vel_filt_enable: bool = true
const pos_filt_cutoff: float = 20.0
const vel_filt_cutoff: float = 20.0
const posz_filt_enable: bool = true
const velz_filt_enable: bool = true
const posz_filt_cutoff: float = 20.0
const velz_filt_cutoff: float = 20.0

(* Libel__pid_params_25_0000001_0000000_0000000_010000100_00000020_000000truetruetrue5000_00000022_000000__step *)
const pid_vx_kp: float = 25.0
const pid_vx_ki: float = 1.0
const pid_vx_kd: float = 0.0
const pid_vx_dt: float = pos_update_dt

(* Libel__pid_params_25_0000001_0000000_0000000_010000100_00000020_000000truetruetrue5000_00000022_000000__step *)
const pid_vy_kp: float = 25.0
const pid_vy_ki: float = 1.0
const pid_vy_kd: float = 0.0
const pid_vy_dt: float = pos_update_dt

(* Libel__pid_params_25_00000015_0000000_0000000_010000100_00000020_000000truetruetrue5000_00000032_767500__step *)
const pid_vz_kp: float = 25.0
const pid_vz_ki: float = 15.0
const pid_vz_kd: float = 0.0
const pid_vz_dt: float = pos_update_dt

(* Libel__pid_params_2_0000000_0000000_0000000_010000100_00000020_000000truetruefalse5000_0000000_000000__step *)
const pid_x_kp: float = 2.0
const pid_x_ki: float = 0.0
const pid_x_kd: float = 0.0
const pid_x_dt: float = pos_update_dt

(* Libel__pid_params_2_0000000_0000000_0000000_010000100_00000020_000000truetruefalse5000_0000000_000000__step *)
const pid_y_kp: float = 2.0
const pid_y_ki: float = 0.0
const pid_y_kd: float = 0.0
const pid_y_dt: float = pos_update_dt

(* Libel__pid_params_2_0000000_5000000_0000000_010000100_00000020_000000truetruefalse5000_0000000_000000__step *)
const pid_z_kp: float = 2.0
const pid_z_ki: float = 0.5
const pid_z_kd: float = 0.0
const pid_z_dt: float = pos_update_dt


(* Libel__constrain_params__5000_0000005000_000000__step *)
const default_pid_integration_limit: float = 5000.0
const default_pid_integration_lim: bool = true
(* Libel__constrain_params__0_0000000_000000__step *)
const default_pid_output_limit: float = 0.0
const default_pid_output_lim: bool = false


const thrust_base: float = 36000.0
(* Libel__constrain_params_20000_00000065535_000000__step *)
const thrust_min: float = 20000.0
(* Libel__constrain_params__20_00000020_000000__step *)
const rollLimit : float = 20.0
const pitchLimit : float = 20.0
const rpLimitOverhead : float = 1.10

const xVelMax : float = 1.0
const yVelMax : float = 1.0
const zVelMax : float = 1.0
const velMaxOverhead : float = 1.10

const thrustScale : float = 1000.0

const pi: float = 3.14159265358979323846

const max_uint16 : int = 0xffff
const max_int16 : int = 0x7fff
const max_uint16_f : float = 65535.0

fun lpf2pSetCutoffFreq(sample_freq, cutoff_freq: float) returns (b0, b1, b2, a1, a2: float)
var fr, ohm, c: float;
let
    fr = sample_freq /. cutoff_freq;
    ohm = tan( pi /. fr );
    c = 1.0 +. 2.0 *. cos( pi /. 4.0 ) *. ohm +. ohm *. ohm;
    b0 = ohm *. ohm /. c;
    b1 = 2.0 *. b0;
    b2 = b0;
    a1 = 2.0 *. ( ohm *. ohm -. 1.0) /. c;
    a2 = ( 1.0 -. 2.0 *. cos( pi /. 4.0 ) *. ohm +. ohm *. ohm ) /. c;
tel



node constrain<<min, max : float>>(input : float) returns (output : float)
let
    output = 
        if input <. min then 
            min 
        else if input >. max then
            max
        else
            input;
tel

node opt_constrain<<limit : float>>(input : float) returns (output : float)
var lim : bool;
let
    lim = round(limit) <> 0;
    output = 
        if lim then constrain<< -. limit, limit>>(input)
        else input;
tel

node lpf2p<<samplingRate, cutoffFreq : float; enableDFilter : bool>>(sample : float) returns (output : float)
var out_filter, delay_0, delay_1, delay_2 : float;
    b0, b1, b2, a1, a2: float;
let
    (b0, b1, b2, a1, a2) = lpf2pSetCutoffFreq(samplingRate, cutoffFreq);

    delay_0 = sample -. delay_1 *. a1 -. delay_2 *. a2;
    out_filter = delay_0 *. b0 +. delay_1 *. b1 +. delay_2 *. b2;
    delay_1 = 0.0 fby delay_0;
    delay_2 = 0.0 fby delay_1;

    output = if enableDFilter then out_filter else sample;
tel

node pid_err<<kp, ki, kd, dt, samplingRate, cutoffFreq : float;
            enableDFilter : bool;
            iLimit, oLimit: float>>(err: float) returns (output : float)
var prev_err, integ : float; (* PID memory *)
    deriv : float;
let
    prev_err = 0.0 fby err;
    integ = opt_constrain<<iLimit>>(0.0 fby integ +. err *. dt);
    deriv = lpf2p<<samplingRate, cutoffFreq, enableDFilter>>((err -. prev_err) /. dt);

    output = opt_constrain<<oLimit>>(kp *. err +. ki *. integ +. kd *. deriv);
tel

node pid<<kp, ki, kd, dt, samplingRate, cutoffFreq : float;
            enableDFilter : bool;
            iLimit, oLimit: float>>(desired, measured : float) returns (output : float)
let
    output = pid_err<<kp, ki, kd, dt, samplingRate, cutoffFreq,
                      enableDFilter,
                      iLimit, oLimit>>(desired -. measured);
tel

(** Data structures *)

type vec3 = {
     x : float;
     y : float;
     z : float
}

type attitude = {
     roll : float;
     pitch : float;
     yaw : float
}

type quaternion = {
     qx : float;
     qy : float;
     qz : float;
     qw : float
}

type stab_mode = Disable | Abs | Velocity

type mode = {
     mx : stab_mode;
     my : stab_mode;
     mz : stab_mode;
     mroll : stab_mode;
     mpitch : stab_mode;
     myaw : stab_mode;
     mquat : stab_mode
}

type baro = {
     pressure : float;
     temperature : float;
     asl : float
}

type sensor_data = {
     acc : vec3;
     gyro : vec3;
     mag : vec3;
     baro : baro
}

type setpoint = {
     attitude : attitude;
     attitude_rate : attitude;
     attitude_quat : quaternion;
     thrust : float;
     position : vec3;
     velocity : vec3;
     acceleration : vec3;
     velocity_body : bool;
     mode : mode
}

type state_t = {
     st_attitude : attitude;
     st_attitude_quat : quaternion;
     st_position : vec3;
     st_velocity : vec3;
     st_acc : vec3
}

type control = {
    c_roll    : int;
    c_pitch   : int;
    c_yaw     : int;
    c_thrust  : float
}

(* Position Controller *)

node everyn<<n : int>>() returns (v : bool);
var x : int;
let
  x = 0 fby ((x + 1) % n);
  v = (x = 0);
tel

node cap_angle(x : float)
returns (y : float)
let
  y = if x >. 180.0 then fmod(x, 360.0) -. 360.0
      else if x <. -.180.0 then fmod(x, 360.0) +. 360.0
      else x
tel

node velocity_controller(velocity : vec3; st : state_t) returns (thrust, pitch, roll : float)
var cosyaw, sinyaw, state_body_vx, state_body_vy, thrustRaw : float;
let
    cosyaw = cos(st.st_attitude.yaw *. pi /. 180.0);
    sinyaw = sin(st.st_attitude.yaw *. pi /. 180.0);

    state_body_vx = st.st_velocity.x *. cosyaw +. st.st_velocity.y *. sinyaw;
    state_body_vy = -. st.st_velocity.x *. sinyaw +. st.st_velocity.y *. cosyaw;

    pitch =
    constrain<<  -. pitchLimit, pitchLimit>>(
        -.pid<<pid_vx_kp, pid_vx_ki, pid_vx_kd, pos_update_dt,
             position_rate, vel_filt_cutoff, vel_filt_enable,
             default_pid_integration_limit, pitchLimit *. rpLimitOverhead>>
             (velocity.x, state_body_vx)
    );

    roll =
    constrain<< -. rollLimit, rollLimit>>(
        -.pid<<pid_vy_kp, pid_vy_ki, pid_vy_kd, pos_update_dt,
             position_rate, vel_filt_cutoff, vel_filt_enable,
             default_pid_integration_limit, rollLimit *. rpLimitOverhead>>
             (velocity.y, state_body_vy)
    );

    thrustRaw =
    pid<<pid_vz_kp, pid_vz_ki, pid_vz_kd, pos_update_dt,
                     position_rate, velz_filt_cutoff, velz_filt_enable,
                     default_pid_integration_limit, max_uint16_f /. 2.0 /. thrustScale>>
                (velocity.z, st.st_velocity.z);

    thrust =
    constrain<<thrust_min, max_uint16_f>>(thrustRaw *. thrustScale +. thrust_base);
tel

node position_controller(setpoint: setpoint; st : state_t)
returns (thrust, pitch, roll: float)
var cosyaw, sinyaw, setp_body_x, setp_body_y, state_body_x, state_body_y: float;
    velocity : vec3;
let
    cosyaw = cos(st.st_attitude.yaw *. pi /. 180.0);
    sinyaw = sin(st.st_attitude.yaw *. pi /. 180.0);

    setp_body_x = setpoint.position.x *. cosyaw +. setpoint.position.y *. sinyaw;
    setp_body_y = -. setpoint.position.x *. sinyaw +. setpoint.position.y *. cosyaw;

    state_body_x = st.st_position.x *. cosyaw +. st.st_position.y *. sinyaw;
    state_body_y = -. st.st_position.x *. sinyaw +. st.st_position.y *. cosyaw;

    velocity = {
        x =
            if setpoint.mode.mx = Abs then
                pid<<pid_x_kp, pid_x_ki, pid_x_kd, pos_update_dt,
                    position_rate, pos_filt_cutoff, pos_filt_enable,
                    default_pid_integration_limit, xVelMax *. velMaxOverhead>>
                (setp_body_x, state_body_x)
            else if not setpoint.velocity_body then
                setpoint.velocity.x *. cosyaw +. setpoint.velocity.y *. sinyaw
            else
                setpoint.velocity.x
            ;

        y =
            if setpoint.mode.my = Abs then
                pid<<pid_y_kp, pid_y_ki, pid_y_kd, pos_update_dt,
                    position_rate, pos_filt_cutoff, pos_filt_enable,
                    default_pid_integration_limit, yVelMax *. velMaxOverhead>>
                (setp_body_y, state_body_y)
            else if not setpoint.velocity_body then
                setpoint.velocity.y *. cosyaw -. setpoint.velocity.x *. sinyaw
            else
                setpoint.velocity.y
            ;

        z =
            if setpoint.mode.mz = Abs then
                pid<<pid_z_kp, pid_z_ki, pid_z_kd, pos_update_dt,
                    position_rate, posz_filt_cutoff, posz_filt_enable,
                    default_pid_integration_limit, zVelMax *. velMaxOverhead>>
                (setpoint.position.z, st.st_position.z)
            else
                setpoint.velocity.z
    };

    (thrust, pitch, roll) = velocity_controller(velocity, st);
tel

(** Attitude Controller *)

node attitudeControllerCorrectAttitudePID
    (eulerRollActual, eulerPitchActual, eulerYawActual,
     eulerRollDesired, eulerPitchDesired, eulerYawDesired : float;
     setpoint : setpoint)
    returns (rollRateDesired, pitchRateDesired, yawRateDesired : float);
var yaw_err, real_yaw_err, rollRateDesired_pid, pitchRateDesired_pid : float;
    resetRoll, resetPitch : bool;
let
    resetRoll = setpoint.mode.mroll = Velocity;
    resetPitch = setpoint.mode.mpitch = Velocity;

    yaw_err = eulerYawDesired -. eulerYawActual;
    real_yaw_err = cap_angle(yaw_err);

    reset
        rollRateDesired_pid = 
            pid<<pid_roll_kp, pid_roll_ki, pid_roll_kd,
                 attitude_update_dt, attitude_rate, attitude_lpf_cutoff_freq,
                 attitude_lpf_enable,
                 pid_roll_integration_limit, 0.0>>(eulerRollDesired, eulerRollActual)
    every resetRoll;

    reset
        pitchRateDesired_pid =
            pid<<pid_pitch_kp, pid_pitch_ki, pid_pitch_kd,
                 attitude_update_dt, attitude_rate, attitude_lpf_cutoff_freq,
                 attitude_lpf_enable,
                 pid_pitch_integration_limit, 0.0>>(eulerPitchDesired, eulerPitchActual)
    every resetPitch;

    rollRateDesired = 
        if resetRoll then
            setpoint.attitude_rate.roll
        else
            rollRateDesired_pid;

    pitchRateDesired =
        if resetPitch then
            setpoint.attitude_rate.pitch
        else
            pitchRateDesired_pid;


    yawRateDesired =
        pid_err<<pid_yaw_kp, pid_yaw_ki, pid_yaw_kd,
                 attitude_update_dt, attitude_rate, attitude_lpf_cutoff_freq,
                 attitude_lpf_enable,
                 pid_yaw_integration_limit, 0.0>>
                 (real_yaw_err);
tel

node saturate_int16(xf : float) returns (y : int)
var x : int;
let
    x = round(floor(xf));
    y = if x > max_int16 then max_int16
        else if x < -max_int16 then -max_int16 else x
tel

node attitudeControllerCorrectRatePID
    (rollRateActual, pitchRateActual, yawRateActual,
     rollRateDesired, pitchRateDesired, yawRateDesired : float)
    returns (rollOutput, pitchOutput, yawOutput : int);
var rollOutput_float, pitchOutput_float, yawOutput_float : float;
let
    rollOutput_float =
        pid<<pid_roll_rate_kp, pid_roll_rate_ki, pid_roll_rate_kd,
             attitude_update_dt, attitude_rate, attitude_lpf_rate_cutoff_freq,
             attitude_lpf_rate_enable,
             pid_roll_rate_integration_limit, 0.0>>(rollRateDesired, rollRateActual);

    pitchOutput_float =
        pid<<pid_pitch_rate_kp, pid_pitch_rate_ki, pid_pitch_rate_kd,
             attitude_update_dt, attitude_rate, attitude_lpf_rate_cutoff_freq,
             attitude_lpf_rate_enable,
             pid_pitch_rate_integration_limit, 0.0>>(pitchRateDesired, pitchRateActual);

    yawOutput_float =
        pid<<pid_yaw_rate_kp, pid_yaw_rate_ki, pid_yaw_rate_kd,
             attitude_update_dt, attitude_rate, attitude_lpf_rate_cutoff_freq,
             attitude_lpf_rate_enable,
             pid_yaw_rate_integration_limit, 0.0>>(yawRateDesired, yawRateActual);

    rollOutput  = saturate_int16(rollOutput_float);
    pitchOutput = saturate_int16(pitchOutput_float);
    yawOutput   = - saturate_int16(yawOutput_float);
tel

node attitudeController(attitudeDesired : attitude;
                        st : state_t;
                        sensors : sensor_data;
                        setpoint : setpoint)
    returns (roll, pitch, yaw : int);
var rollRateDesired, pitchRateDesired, yawRateDesired : float;
let
    (rollRateDesired, pitchRateDesired, yawRateDesired) = 
        attitudeControllerCorrectAttitudePID(
            st.st_attitude.roll, st.st_attitude.pitch, st.st_attitude.yaw,
            attitudeDesired.roll, attitudeDesired.pitch, attitudeDesired.yaw,
            setpoint
        );

    (roll,pitch,yaw) = attitudeControllerCorrectRatePID(
            sensors.gyro.x, -. sensors.gyro.y, sensors.gyro.z,
            rollRateDesired, pitchRateDesired, yawRateDesired
        );
tel

(* main cascaded pid controller that calls sub-controllers *)

node controller_pid (sensors: sensor_data; st: state_t; setpoint: setpoint)
returns (control: control);
var freq_attitude, freq_position: bool;
    last cap_yaw: float = 0.0;
    last roll_pos_d: float = 0.0; last pitch_pos_d: float = 0.0; last thrust_pos_d: float = 0.0;
    last attitude_desired: attitude = {roll=0.0; pitch=0.0; yaw=0.0}; last actuator_thrust: float = 0.0;
    last roll_d: int = 0; last yaw_d: int = 0; last pitch_d: int = 0;
    last control_d: control = {c_roll=0; c_pitch = 0; c_yaw = 0; c_thrust = 0.0};
let
    freq_attitude = everyn<<2>>();
    freq_position = everyn<<10>>();

    switch freq_attitude
    | true do cap_yaw =
        if setpoint.mode.myaw = Velocity
        then cap_angle((last attitude_desired).yaw +. setpoint.attitude_rate.yaw *. attitude_update_dt)
        else cap_angle(setpoint.attitude.yaw)
    | false do cap_yaw = (last attitude_desired).yaw;
    end;

    switch freq_position
    | true do
        reset
            (thrust_pos_d, pitch_pos_d, roll_pos_d) = position_controller(setpoint, st);
        every (false fby (control.c_thrust = 0.0));
    | false do
        thrust_pos_d = last actuator_thrust;
        pitch_pos_d = (last attitude_desired).pitch;
        roll_pos_d = (last attitude_desired).roll;
    end;

    switch freq_attitude
    | true do
        actuator_thrust = if (setpoint.mode.mz = Disable) then setpoint.thrust 
                          else thrust_pos_d;
        switch (setpoint.mode.mx = Disable or setpoint.mode.my = Disable)
        | true do attitude_desired = { setpoint.attitude with .yaw = cap_yaw }
        | false do attitude_desired = { pitch = pitch_pos_d; roll = roll_pos_d; yaw = cap_yaw }
        end;

        reset
            (roll_d, pitch_d, yaw_d) = attitudeController( attitude_desired, st, sensors, setpoint);
        every (false fby (control.c_thrust = 0.0));
        control_d = {c_roll = roll_d; c_pitch = pitch_d; c_yaw = yaw_d; c_thrust = actuator_thrust}
    | false do
        actuator_thrust = thrust_pos_d;
    end;

    switch (control_d.c_thrust = 0.0)
    | true do control = {c_roll = 0; c_pitch = 0; c_yaw = 0; c_thrust = 0.0}
    | false do control = control_d
    end;
tel


(** Power distribution *)

fun limitUint16(i : int) returns (o : int)
let
    o = if i > max_uint16 then max_uint16
        else if i < 0 then 0 else i;
tel

const idle_thrust : int = 0

fun min_idle(i : int) returns (o : int)
let
    o = if i < idle_thrust then idle_thrust else i;
tel

fun power_distribution(thrust : float; roll, pitch, yaw : int)
returns (m1, m2, m3, m4 : int)
var r, p, t : int;
let
    r = roll / 2;
    p = pitch / 2;
    t = round(thrust);
    m1 = min_idle(limitUint16(t - r + p + yaw));
    m2 = min_idle(limitUint16(t - r - p - yaw));
    m3 = min_idle(limitUint16(t + r - p + yaw));
    m4 = min_idle(limitUint16(t + r + p - yaw));
tel



(* ------------------------------------------------------------------------------------------------------ *)

(* State Estimator *)

(* Constants *)

const attitude_update_rate_estimator: float = rate_250_hz
const attitude_update_dt_estimator: float = 1.0 /. attitude_update_rate_estimator
const position_update_rate: float = rate_100_hz
const position_update_dt: float = 1.0 /. position_update_rate

const pi_f : float = 3.14159265358979323846
const twoKp : float = 2.0 *. 0.4
const twoKi : float = 2.0 *. 0.001
const grav_const : float = 9.81
const max_sample_age: int = 50

(* selfstate variables that remain constant *)
const vAccDeadband: float = 0.04
const velZalpha: float = 0.995
const estAlphaZrange: float = 0.90
const estAlphaAsl: float = 0.90
const velocityFactor: float = 1.0

(* ------------------------------------------------------------------------------- *)
(* Data structures *)

type tof = {
    timestamp : int;
    distance : float;
    stdDev   : float
}

type sensor_data_est = {
    acc_est : vec3;
    gyro_est : vec3;
    tof : tof;
    baro_est : baro
}

(* ------------------------------------------------------------------------------- *)
(* miscelaneous functions *)

fun normalize(acc: vec3) returns (acc_norm: vec3);
var recipNorm : float;
let
    recipNorm = invSqrt((acc.x *. acc.x) +. (acc.y *. acc.y) +. (acc.z *. acc.z));
    acc_norm = {x = acc.x *. recipNorm;
                y = acc.y *. recipNorm;
                z = acc.z *. recipNorm};
tel

fun normalize_quat(q: quaternion) returns (q_norm: quaternion);
var recipNorm: float;
let
    recipNorm = invSqrt((q.qw *. q.qw) +. (q.qx *. q.qx) +. (q.qy *. q.qy) +. (q.qz *. q.qz));
    q_norm = {qx = q.qx *. recipNorm;
              qy = q.qy *. recipNorm;
              qz = q.qz *. recipNorm;
              qw = q.qw *. recipNorm};
tel

(* Estimated direction of gyro and vector perpendicular to magnetic flux *)
(* Error is sum of cross product between estimated and measured direction of gyro *)
fun getEstimatedGyroAndMagError(q: quaternion; acc_1: vec3)
returns (halfe: vec3);
var halfvx, halfvy, halfvz : float;
let
    halfvx = (q.qx *. q.qz) -. (q.qw *. q.qy);
    halfvy = (q.qw *. q.qx) +. (q.qy *. q.qz);
    halfvz = (q.qw *. q.qw) -. 0.5 +. (q.qz *. q.qz);
    halfe = {x = ((acc_1.y *. halfvz) -. (acc_1.z *. halfvy));
             y = ((acc_1.z *. halfvx) -. (acc_1.x *. halfvz));
             z = ((acc_1.x *. halfvy) -. (acc_1.y *. halfvx))};
tel

(* Compute and apply integral feedback *)
node apply_integral_feedback(prev_gyro: vec3; halfe: vec3)
returns (gyro: vec3);
var dt : float;
    last integralFBx: float = 0.0;
    last integralFBy: float = 0.0;
    last integralFBz: float = 0.0;
let
    dt = attitude_update_dt_estimator;
    integralFBx = (last integralFBx) +. ((twoKi  *. dt) *. halfe.x);
    integralFBy = (last integralFBy) +. ((twoKi  *. dt) *. halfe.y);
    integralFBz = (last integralFBz) +. ((twoKi  *. dt) *. halfe.z);
    gyro = {x = prev_gyro.x +. integralFBx;
            y = prev_gyro.y +. integralFBy;
            z = prev_gyro.z +. integralFBz};
tel

(* Integrate rate of change of quaternion *)
fun integrateQuaternion(q: quaternion; gyro: vec3)
returns (q_new: quaternion);
var dt: float;
    gx, gy, gz : float;
    qa, qb, qc, qz : float;
let
    dt = attitude_update_dt_estimator;
    gx = gyro.x *. (0.5 *. dt);
    gy = gyro.y *. (0.5 *. dt);
    gz = gyro.z *. (0.5 *. dt);
    qa = q.qw;
    qb = q.qx;
    qc = q.qy;
    qz = q.qz;
    q_new = {qw = q.qw -. ((qb *. gx) +. (qc *. gy) +. (qz *. gz));
             qx = q.qx +. ((qa *. gx) +. (qc *. gz) -. (qz *. gy));
             qy = q.qy +. ((qa *. gy) -. (qb *. gz) +. (qz *. gx));
             qz = q.qz +. ((qa *. gz) +. (qb *. gy) -. (qc *. gx))};
tel

fun deadband(value: float; threshold: float)
returns (v: float);
let
    v = if fabs(value) <. threshold then 
            0.0 
        else if value >. 0.0 then 
            value -. threshold 
        else if value <. 0.0 then 
            value +. threshold 
        else 
            value;
tel

(* ------------------------------------------------------------------------------- *)
(* sensfusion6 *)

node sensfusion6_update_QImpl(gyro: vec3; acc: vec3)
returns (last q: quaternion = {qw = 1.0; qx = 0.0; qy = 0.0; qz = 0.0});
var gyro0 : vec3;
    last acc_1 : vec3 = {x = 0.0; y = 0.0; z = 0.0};
    last halfe : vec3 = {x = 0.0; y = 0.0; z = 0.0};
    last gyro1 : vec3 = {x = 0.0; y = 0.0; z = 0.0};
    last gyro2 : vec3 = {x = 0.0; y = 0.0; z = 0.0};
    q_temp : quaternion;
let
    gyro0={ x = (gyro.x *. pi_f) /. 180.0;
            y = (gyro.y *. pi_f) /. 180.0;
            z = (gyro.z *. pi_f) /. 180.0};

    switch (not ((acc.x = 0.0) and (acc.y = 0.0) and (acc.z = 0.0)))
    | true do
        acc_1 = normalize(acc);
        halfe = getEstimatedGyroAndMagError(last q, acc_1);
        gyro1 = apply_integral_feedback(gyro0, halfe);
        gyro2 = { x = gyro1.x +. (twoKp *. halfe.x);
                  y = gyro1.y +. (twoKp *. halfe.y);
                  z = gyro1.z +. (twoKp *. halfe.z)};
        q_temp = integrateQuaternion(last q, gyro2);
    | false do
        q_temp = integrateQuaternion(last q, gyro0);
    end;

    q = normalize_quat(q_temp);
tel

node sensfusion6_update_Q(gyro: vec3; acc: vec3)
returns (q: quaternion; grav: vec3; last baseZacc: float = 0.0);
var last is_calibrated : bool = false;
let
    q = sensfusion6_update_QImpl(gyro, acc);
    grav = {x = 2.0 *. ((q.qx *. q.qz) -. (q.qw *. q.qy));
            y = 2.0 *. ((q.qw *. q.qx) +. (q.qy *. q.qz));
            z = (q.qw *. q.qw) -. (q.qx *. q.qx) -. (q.qy *. q.qy) +. (q.qz *. q.qz)};

    switch (not (last is_calibrated))
    | true do
        baseZacc = (acc.x *. grav.x) +. (acc.y *. grav.y) +. (acc.z *. grav.z);
        is_calibrated = true;
    | false do
    end;
tel

fun sensfusion6_get_euler_rpy(q: quaternion; grav: vec3)
returns (attitude: attitude);
var gx: float;
let
    gx = if (grav.x >. 1.0) then 1.0
        else if (grav.x <. (-.1.0)) then (-.1.0)
        else grav.x;
    attitude = {yaw = atan2(2.0 *.((q.qw*.q.qz) +. (q.qx*.q.qy)), ((q.qw*.q.qw) +. (q.qx*.q.qx) -. (q.qy*.q.qy) -. (q.qz*.q.qz))) *. (180.0 /. pi_f);
                pitch = (asin(gx) *. 180.0) /. pi_f;
                roll = (atan2(grav.y, grav.z) *. 180.0) /. pi_f};
tel

(* ------------------------------------------------------------------------------- *)
(* position estimate *)

node position_update_velocity(accWz, init_velocityZ : float)
returns (final_velocityZ: float);
var dt, accWz1: float;
let
    dt = attitude_update_dt_estimator;
    accWz1 = init_velocityZ +. deadband(accWz, vAccDeadband) *. dt *. grav_const;
    final_velocityZ = accWz1 *. velZalpha;
tel

(* Improved_BARO_Z_HOLD macro not defined *)

node positionEstimate(baro: baro; tof: tof; init_velocityZ: float;)
returns (last position_z: float = 0.0; vel_z: float);
var dt: float;
    filteredZ: float;
    isSampleUseful: bool;
let
    dt = position_update_dt;
    isSampleUseful = ((xTaskGetTickCount() - tof.timestamp) <= max_sample_age);

    switch (isSampleUseful)
    | true do
        filteredZ = (estAlphaZrange *. last position_z) +. ((1.0 -. estAlphaZrange) *. tof.distance);
    | false do
        filteredZ = if (last position_z = 0.0) then baro.asl
                    else (estAlphaAsl *. last position_z) +. ((1.0 -. estAlphaAsl) *. baro.asl);
    end;

    position_z = filteredZ +. (velocityFactor *. init_velocityZ *. dt);
    vel_z = (position_z -. (last position_z)) /. dt;
tel

(* ------------------------------------------------------------------------------- *)
(* main state estimator *)

node estimator_complementary(sensor: sensor_data_est)
returns (st : state_t);
var freq_att_update, freq_pos_update : bool;
    last grav: vec3 = {x = 0.0; y = 0.0; z = 0.0};
    last st_attitude_this: attitude = {roll = 0.0; pitch = 0.0; yaw = 0.0};
    last st_attitude_quat_this: quaternion = {qw = 1.0; qx = 0.0; qy = 0.0; qz = 0.0};
    last st_acc_z: float = 0.0;
    last baseZacc: float = 0.0;
    last velocityZ: float = 0.0;
    last st_position_z: float = 0.0;
    last st_velocity_z: float = 0.0;
let
    freq_att_update = everyn<<4>>();
    freq_pos_update = everyn<<10>>();

    switch freq_att_update
    | true do
        (st_attitude_quat_this, grav, baseZacc) = sensfusion6_update_Q(sensor.gyro_est, sensor.acc_est);
        st_attitude_this = sensfusion6_get_euler_rpy(st_attitude_quat_this, grav);
        st_acc_z =  (  (sensor.acc_est.x *. grav.x) 
                    +. (sensor.acc_est.y *. grav.y) 
                    +. (sensor.acc_est.z *. grav.z)
                    ) -. baseZacc;
        velocityZ = position_update_velocity(st_acc_z, last velocityZ);
    | false do
    end;

    switch freq_pos_update
    | true do
        (st_position_z, st_velocity_z) = 
            positionEstimate(sensor.baro_est, sensor.tof, velocityZ);
    | false do
    end;

    st = {  st_attitude = st_attitude_this;
            st_attitude_quat = st_attitude_quat_this;
            st_position = {x = 0.0; y = 0.0; z = st_position_z};
            st_velocity = {x = 0.0; y = 0.0; z = st_velocity_z};
            st_acc = {x = 0.0; y = 0.0; z = st_acc_z}};
tel


(* ---------------------------------------------------------------------------------------- *)
(* LEDs *)

(* constants *)

(* const led_blue_l   : int = 0
const led_green_l  : int = 1
const led_red_l    : int = 2
const led_green_r  : int = 3
const led_red_r    : int = 4
const led_blue_nrf : int = 5

const link_led      : int = led_green_l
const chg_led       : int = led_blue_l
const lowbat_led    : int = led_red_r
const link_down_led : int = led_red_l
const sys_led       : int = led_red_r
const err_led1      : int = led_red_l
const err_led2      : int = led_red_r *)


const led_num: int = 6

(* Individual led states *)

node led_off ()
returns (led_state: bool);
let
    automaton
        state ON
            do led_state = true
            unless true then OFF
        state OFF
            do led_state = false
            unless false then ON
    end
tel

node led_on_every_n_tick (n: int)
returns (led_state: bool);
var last clock: int = 0;
let
    automaton
        state ON
            do led_state = true
            unless ((last clock) > 0) then OFF
        state OFF
            do led_state = false
            unless ((last clock) = 0) then ON
    end;
    clock = ((last clock) + 1) % n;
tel

node led_sequence(leds: bool^led_num; n: int)
returns (led_state: bool^led_num);
var led0, led1, led2, led3, led4, led5: bool;
let
    led0 = if (leds[0]) then led_on_every_n_tick(n) else led_off();
    led1 = if (leds[1]) then led_on_every_n_tick(n) else led_off();
    led2 = if (leds[2]) then led_on_every_n_tick(n) else led_off();
    led3 = if (leds[3]) then led_on_every_n_tick(n) else led_off();
    led4 = if (leds[4]) then led_on_every_n_tick(n) else led_off();
    led5 = if (leds[5]) then led_on_every_n_tick(n) else led_off();
    led_state = [
                led0,
                led1,
                led2,
                led3,
                led4,
                led5
            ];
tel    

(* main led sequence driver functions *)

node set_leds(leds: bool^led_num)
returns (ok: bool);
var ok1, ok2, ok3, ok4, ok5: bool;
let
    ok = led_set(0, leds[0]);
    ok1 = led_set(1, leds[1]);
    ok2 = led_set(2, leds[2]);
    ok3 = led_set(3, leds[3]);
    ok4 = led_set(4, leds[4]);
    ok5 = led_set(5, leds[5]);
tel

node led_seq_everyn(n: int)
returns (sequence: bool^led_num;);
var last clock: int = 0;
    led_on, led_off: bool;
    ok: bool;
let
    led_on = led_on_every_n_tick(n);
    led_off = led_off();
    automaton
        state BLUE_L
            do  sequence = [led_on, led_off, led_off, led_off, led_off, led_off];
                ok = set_leds(sequence);
            unless ((last clock) > 20) then GREEN_L
        state GREEN_L
            do  sequence = [led_off, led_on, led_off, led_off, led_off, led_off];
                ok = set_leds(sequence);
            unless ((last clock) > 40) then RED_L
        state RED_L
            do  sequence = [led_off, led_off, led_on, led_off, led_off, led_off];
                ok = set_leds(sequence);
            unless ((last clock) > 60) then GREEN_R
        state GREEN_R
            do  sequence = [led_off, led_off, led_off, led_on, led_off, led_off];
                ok = set_leds(sequence);
            unless ((last clock) > 80) then RED_R
        state RED_R
            do  sequence = [led_off, led_off, led_off, led_off, led_on, led_off];
                ok = set_leds(sequence);
            unless ((last clock) > 100) then BLUE_R
        state BLUE_R
            do  sequence = [led_off, led_off, led_off, led_off, led_off, led_on];
                ok = set_leds(sequence);
            unless ((last clock) = 0) then BLUE_L
    end;
    clock = ((last clock) + 1) % 120;
tel

node ledseq_task()
returns (last led_state: bool^led_num = false^led_num);
var led_freq: bool;
let
    led_freq = everyn<<100>>();
    
    switch (led_freq)
    | true do
        led_state = led_seq_everyn(2);
    | false do
    end;
tel