open Mathext

const pid_roll_rate_kp: float = 250.0
const pid_roll_rate_ki: float = 500.0
const pid_roll_rate_kd: float = 2.5
const pid_roll_rate_intergration_limit: float = 33.3
const pid_roll_rate_intergration_lim: bool = true

const pid_pitch_rate_kp: float = 250.0
const pid_pitch_rate_ki: float = 500.0
const pid_pitch_rate_kd: float = 2.5
const pid_pitch_rate_intergration_limit: float = 33.3
const pid_pitch_rate_intergration_lim: bool = true

const pid_yaw_rate_kp: float = 120.0
const pid_yaw_rate_ki: float = 16.7
const pid_yaw_rate_kd: float = 0.0
const pid_yaw_rate_intergration_limit: float = 166.7
const pid_yaw_rate_intergration_lim: bool = true

const pid_roll_kp: float = 6.0
const pid_roll_ki: float = 3.0
const pid_roll_kd: float = 0.0
const pid_roll_intergration_limit: float = 20.0
const pid_roll_intergration_lim: bool = true

const pid_pitch_kp: float = 6.0
const pid_pitch_ki: float = 3.0
const pid_pitch_kd: float = 0.0
const pid_pitch_intergration_limit: float = 20.0
const pid_pitch_intergration_lim: bool = true

const pid_yaw_kp: float = 6.0
const pid_yaw_ki: float = 1.0
const pid_yaw_kd: float = 0.35
const pid_yaw_intergration_limit: float = 360.0
const pid_yaw_intergration_lim: bool = true

const default_pid_intergration_limit: float = 5000.0
const default_pid_intergration_lim: bool = true
const default_pid_output_limit: float = 0.0
const default_pid_output_lim: bool = false

const attitude_lpf_cutoff_freq: float = 15.0
const attitude_lpf_enable: bool = false
const attitude_lpf_rate_cutoff_freq: float = 30.0
const attitude_lpf_rate_enable: bool = false

const rate_1000_hz: float = 1000.0
const rate_500_hz: float = 500.0
const rate_250_hz: float = 250.0
const rate_100_hz: float = 100.0
const rate_50_hz: float = 50.0
const rate_25_hz: float = 25.0

const rate_main_loop: float = rate_1000_hz
const attitude_rate: float = rate_500_hz
const position_rate: float = rate_100_hz
const rate_hl_commander: float = rate_100_hz

const attitude_update_rate: float = rate_250_hz
const attitude_update_dt: float = 1.0 /. attitude_update_rate

const pos_update_rate: float = rate_100_hz
const pos_update_dt: float = 1.0 /. pos_update_rate

const pos_filt_enable: bool = true
const vel_filt_enable: bool = true
const pos_filt_cutoff: float = 20.0
const vel_filt_cutoff: float = 20.0
const posz_filt_enable: bool = true
const velz_filt_enable: bool = true
const posz_filt_cutoff: float = 20.0
const velz_filt_cutoff: float = 20.0

const pid_dt: float = 1.0 /. position_rate

const pid_vx_kp: float = 25.0
const pid_vx_ki: float = 1.0
const pid_vx_kd: float = 0.0
const pid_vx_dt: float = pid_dt

const pid_vy_kp: float = 25.0
const pid_vy_ki: float = 1.0
const pid_vy_kd: float = 0.0
const pid_vy_dt: float = pid_dt

const pid_vz_kp: float = 25.0
const pid_vz_ki: float = 15.0
const pid_vz_kd: float = 0.0
const pid_vz_dt: float = pid_dt

const pid_x_kp: float = 2.0
const pid_x_ki: float = 0.0
const pid_x_kd: float = 0.0
const pid_x_dt: float = pid_dt

const pid_y_kp: float = 2.0
const pid_y_ki: float = 0.0
const pid_y_kd: float = 0.0
const pid_y_dt: float = pid_dt

const pid_z_kp: float = 2.0
const pid_z_ki: float = 0.5
const pid_z_kd: float = 0.0
const pid_z_dt: float = pid_dt

const thrust_base: float = 36000.0
const thrust_min: float = 20000.0
const rollLimit : float = 20.0
const pitchLimit : float = 20.0
const rpLimitOverhead : float = 1.10
const thrustScale : float = 1000.0


const pi: float = 3.14159265358979323846
const one: float = 1.0
const two: float = 2.0
const four: float = 4.0
const deg_to_rad : float = 0.01745329251


const max_uint16 : int = 0xffff
const max_uint16_f : float = 65535.0


fun lpf2pSetCutoffFreq(sample_freq, cutoff_freq: float) returns (b0, b1, b2, a1, a2: float)
var fr, ohm, c: float;
let
    fr = sample_freq /. cutoff_freq;
    ohm = tan( pi /. fr );
    c = one +. two *. cos( pi /. four ) *. ohm +. ohm *. ohm;
    b0 = ohm *. ohm /. c;
    b1 = two *. b0;
    b2 = b0;
    a1 = two *. ( ohm *. ohm -. one ) /. c;
    a2 = ( one -. two *. cos( pi /. four ) *. ohm +. ohm *. ohm ) /. c;
tel



node constrain<<min, max : float>>(input : float) returns (output : float)
let
    output = 
        if input <. min then 
            min 
        else if input >. max then
            max
        else
            input;
tel

node opt_constrain<<limit : float; lim : bool>>(input : float) returns (output : float)
let
    output = 
        if lim then
            input
        else
            constrain<< -. limit, limit>>(input);
tel

node lpf2p<<samplingRate, cutoffFreq : float; enableDFilter : bool>>(sample : float) returns (output : float)
var out_filter, delay_0, delay_1, delay_2 : float;
    b0, b1, b2, a1, a2: float;
let
    (b0, b1, b2, a1, a2) = lpf2pSetCutoffFreq(samplingRate, cutoffFreq);

    delay_0 = sample -. delay_1 *. a1 -. delay_2 *. a2;
    out_filter = delay_0 *. b0 +. delay_1 *. b1 +. delay_2 *. b2;
    delay_1 = 0.0 fby delay_0;
    delay_2 = 0.0 fby delay_1;

    output = if enableDFilter then out_filter else sample;
tel

node pid<<kp, ki, kd, dt, samplingRate, cutoffFreq : float;
            enableDFilter, iLim, oLim : bool;
            iLimit, oLimit: float>>(desired, measured : float) returns (output : float)
var prev_err, integ : float; (* PID memory *)
    err,deriv : float;
let
    err = desired -. measured;
    prev_err = 0.0 fby err;
    integ = opt_constrain<<iLimit, iLim>>(0.0 fby integ +. err *. dt);
    deriv = lpf2p<<samplingRate, cutoffFreq, enableDFilter>>((err -. prev_err) /. dt);

    output = opt_constrain<<oLimit, oLim>>(kp *. err +. ki *. integ +. kd *. deriv);
tel

(** Position Controller *)

type vec3 = {
     x : float;
     y : float;
     z : float
}

type attitude = {
     roll : float;
     pitch : float;
     yaw : float
}

type quaternion = {
     qx : float;
     qy : float;
     qz : float;
     qw : float
}

type stab_mode = Disable | Abs | Velocity

type mode = {
     mx : stab_mode;
     my : stab_mode;
     mz : stab_mode;
     mroll : stab_mode;
     mpitch : stab_mode;
     myaw : stab_mode;
     mquat : stab_mode
}

type baro = {
     pressure : float;
     temperature : float;
     asl : float
}

type sensor_data = {
     acc : vec3;
     gyro : vec3;
     mag : vec3;
     baro : baro
}

type setpoint = {
     attitude : attitude;
     attitude_rate : attitude;
     attitude_quat : quaternion;
     thrust : float;
     position : vec3;
     velocity : vec3;
     acceleration : vec3;
     velocity_body : bool;
     mode : mode
}

type state_t = {
     st_attitude : attitude;
     st_attitude_quat : quaternion;
     st_position : vec3;
     st_velocity : vec3;
     st_acc : vec3
}

node controller_pid1(setpin : setpoint; st : state_t)
returns (thrust : float; att_desired : attitude; setpout : setpoint)
let
    thrust = 0.0 fby 1.1;
    att_desired = { roll = 0.0; pitch = 0.0; yaw = 0.0 };
    setpout = setpin;
tel

(*
node position_controller(setpin: setpoint; st : state_t)
returns (thrust, pitch, roll: float; vout : vec3)
var cosyaw, sinyaw, setp_body_x, setp_body_y, state_body_x, state_body_y: float;
let
    cosyaw = cos(state.st_attitude.yaw *. deg_to_rad);
    sinyaw = sin(state.st_attitude.yaw *. deg_to_rad);

    setp_body_x = setpin.velocity.x *. cosyaw +. setpin.velocity.y *. sinyaw;
    setp_body_y = setpin.velocity.x *. sinyaw +. setpin.velocity.y *. cosyaw;

    state_body_x = 

    vout.x =
    if stepin.mode.x = Abs then
        pid<<pid_x_kp, pid_x_ki, pid_x_kd, pid_dt, position_rate, pos_filt_cutoff, pos_filt_enable, default_pid_intergration_limit, default_pid_output_limit>>
        (setp_body_x, state_body_x)
    else if not setpin.velocity_body then
        setpin.velocity.x *. cosyaw +. setpin.velocity.y *. sinyaw
    else
        setpin.velocity.x
    ;

    vout.y =
    if setpin.mode.y = Abs then
        pid<<pid_y_kp, pid_y_ki, pid_y_kd, pid_dt, position_rate, pos_filt_cutoff, pos_filt_enable, default_pid_intergration_limit, default_pid_output_limit>>
        (setp_body_y, state_body_y)
    else if not setpin.velocity_body then
        setpin.velocity.y *. cosyaw -. setpin.velocity.x *. sinyaw
    else
        setpin.velocity.y
    ;

    vout.z =
    if setpin.mode.z = Abs then
        pid<<pid_z_kp, pid_z_ki, pid_z_kd, pid_dt, position_rate, posz_filt_cutoff, posz_filt_enable, default_pid_intergration_limit, default_pid_output_limit>>
        (setpin.position.z, st.position.z)
    else
        setpin.velocity.z
    ;

    thurst, pitch, roll = velocity_controller(setpin, st);
tel
*)

node velocity_controller(setpin : vec3; st : state_t) returns (thrust, pitch, roll : float)
var cosyaw, sinyaw, state_body_vx, state_body_vy, thrustRaw : float;
let
    cosyaw = cos(st.st_attitude.yaw *. deg_to_rad);
    sinyaw = sin(st.st_attitude.yaw *. deg_to_rad);
    state_body_vx = st.st_velocity.x *. cosyaw +. st.st_velocity.y *. sinyaw;
    state_body_vy = -. st.st_velocity.x *. sinyaw +. st.st_velocity.y *. cosyaw;

    pitch = (* constrain<<  -. pitchLimit, pitchLimit>>(
        pid<<pid_vx_kp, pid_vx_ki, pid_vx_kd, pid_dt,
             position_rate, vel_filt_cutoff, vel_filt_enable,
             default_pid_intergration_lim, true,
             default_pid_intergration_limit, pitchLimit *. rpLimitOverhead>>
             (setpin.x, state_body_vx)
        (* kFFx == 0.0 ? *)
    ); *) 0.0;
    roll = (* constrain<< -. rollLimit, rollLimit>>(
        pid<<pid_vy_kp, pid_vy_ki, pid_vy_kd, pid_dt,
             position_rate, vel_filt_cutoff, vel_filt_enable,
             default_pid_intergration_lim, true,
             default_pid_intergration_limit, rollLimit *. rpLimitOverhead>>
             (setpin.y, state_body_vy)
    ); *) 0.0;

    thrustRaw = (* pid<<pid_vz_kp, pid_vz_ki, pid_vz_kd, pid_dt,
                     position_rate, velz_filt_cutoff, velz_filt_enable,
                     default_pid_intergration_lim, true,
                     default_pid_intergration_limit, max_uint16_f /. two /. thrustScale>>
                (setpin.z, st.st_velocity.z); *) 0.0;
    thrust = (* constrain<<thrust_min, max_uint16_f>>(thrustRaw *. thrustScale +. thrust_base); *) 0.0;
tel

(** Power distribution *)

fun limitUint16(i : int) returns (o : int)
let
    o = if i > max_uint16 then max_uint16
        else if i < 0 then 0 else i;
tel

const idle_thrust : int = 0

fun min_idle(i : int) returns (o : int)
let
    o = if i < idle_thrust then idle_thrust else i;
tel

fun power_distribution(thrust : float; roll, pitch, yaw : int)
returns (m1, m2, m3, m4 : int)
var r, p, t : int;
let
    r = roll / 2;
    p = pitch / 2;
    t = round(thrust);
    m1 = min_idle(limitUint16(t - r + p + yaw));
    m2 = min_idle(limitUint16(t - r - p - yaw));
    m3 = min_idle(limitUint16(t + r - p + yaw));
    m4 = min_idle(limitUint16(t + r + p - yaw));
tel

const idX : int = 0
const idY : int = 1
const idZ : int = 2


